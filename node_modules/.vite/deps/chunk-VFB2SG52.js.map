{
  "version": 3,
  "sources": ["../../base64-js/index.js", "../../convex/src/values/values.ts"],
  "sourcesContent": ["'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n", "/**\n * Utilities for working with values stored in Convex.\n *\n * You can see the full set of supported types at\n * [Types](https://docs.convex.dev/using/types).\n * @module\n */\nimport * as Base64 from \"base64-js\";\n\nconst LITTLE_ENDIAN = true;\n// This code is used by code that may not have bigint literals.\nconst MIN_INT64 = BigInt(\"-9223372036854775808\");\nconst MAX_INT64 = BigInt(\"9223372036854775807\");\nconst ZERO = BigInt(\"0\");\nconst EIGHT = BigInt(\"8\");\nconst TWOFIFTYSIX = BigInt(\"256\");\n\n/**\n * The type of JavaScript values serializable to JSON.\n *\n * @public\n */\nexport type JSONValue =\n  | null\n  | boolean\n  | number\n  | string\n  | JSONValue[]\n  | { [key: string]: JSONValue };\n\n/**\n * An identifier for a document in Convex.\n *\n * Convex documents are uniquely identified by their `Id`, which is accessible\n * on the `_id` field. To learn more, see [Data Modeling](https://docs.convex.dev/using/data-modeling).\n *\n * Documents can be loaded using `db.get(id)` in query and mutation functions.\n *\n * **Important**: Use `myId.equals(otherId)` to check for equality.\n * Using `===` will not work because two different instances of `Id` can refer\n * to the same document.\n *\n * `Id`s are 17 bytes long and consist of:\n * - A 15-byte random value.\n * - A 2-byte timestamp representing the document's creation, in days since the Unix epoch.\n * This is encoded in base 62 ([0-9A-Za-z]).\n *\n * If you're using code generation, use the `Id` class typed for your data model in\n * `convex/_generated/dataModel.js`.\n *\n * @typeParam TableName - A string literal type of the table name (like \"users\").\n *\n * @public\n */\nexport class Id<TableName extends string> {\n  /**\n   * The table name this {@link GenericId} references.\n   */\n  public readonly tableName: TableName;\n\n  /**\n   * The identifier string.\n   *\n   * This contains the characters `[0-9A-Za-z]`.\n   */\n  public readonly id: string;\n\n  constructor(tableName: TableName, id: string) {\n    this.tableName = tableName;\n    this.id = id;\n  }\n\n  /**\n   * Check if this {@link GenericId} refers to the same document as another {@link GenericId}.\n   *\n   * @param other - The other {@link GenericId} to compare to.\n   * @returns `true` if the objects refer to the same document.\n   */\n  equals(other: unknown): boolean {\n    if (other instanceof Id) {\n      return this.tableName === other.tableName && this.id === other.id;\n    }\n    return false;\n  }\n\n  /**\n   * Parse a {@link GenericId} from its JSON representation.\n   */\n  static fromJSON(obj: any): Id<string> {\n    if (typeof obj.$id !== \"string\") {\n      throw new Error(\n        `Object ${JSON.stringify(obj)} isn't a valid Id: $id isn't a string.`\n      );\n    }\n    const parts = obj.$id.split(\"|\");\n    if (parts.length !== 2) {\n      throw new Error(\n        `Object ${JSON.stringify(obj)} isn't a valid Id: Wrong number of parts.`\n      );\n    }\n    return new Id(parts[0], parts[1]);\n  }\n\n  /**\n   * Convert a {@link GenericId} into its JSON representation.\n   */\n  toJSON(): JSONValue {\n    const idString = `${this.tableName}|${this.id}`;\n    return { $id: idString };\n  }\n\n  /**\n   * Convert a {@link GenericId} into its string representation.\n   *\n   * This includes the identifier but not the table name.\n   */\n  toString(): string {\n    return this.id;\n  }\n\n  /**\n   * Pretty-print this {@link GenericId} for debugging.\n   */\n  inspect(): string {\n    return `Id('${this.tableName}', '${this.id}')`;\n  }\n}\n\n/**\n * Internal type used in Convex code generation.\n *\n * @public\n */\nexport type GenericIdConstructor<TableNames extends string> = {\n  new <TableName extends TableNames>(\n    tableName: TableName,\n    id: string\n  ): Id<TableName>;\n  prototype: Id<string>;\n  fromJSON(obj: any): Id<string>;\n};\n\n/**\n * A value supported by Convex.\n *\n * Values can be:\n * - stored inside of documents.\n * - used as arguments and return types to queries and mutation functions.\n *\n * You can see the full set of supported types at\n * [Types](https://docs.convex.dev/using/types).\n *\n * @public\n */\nexport type Value =\n  | Id<string>\n  | null\n  | bigint\n  | number\n  | boolean\n  | string\n  | ArrayBuffer\n  | Value[]\n  | Set<Value>\n  | Map<Value, Value>\n  | { [key: string]: Value };\n\n/**\n * The types of {@link Value} that can be used to represent numbers.\n *\n * @public\n */\nexport type NumericValue = bigint | number;\n\nfunction isSpecial(n: number) {\n  return Number.isNaN(n) || !Number.isFinite(n) || Object.is(n, -0);\n}\n\nexport function slowBigIntToBase64(value: bigint): string {\n  // the conversion is easy if we pretend it's unsigned\n  if (value < ZERO) {\n    value -= MIN_INT64 + MIN_INT64;\n  }\n  let hex = value.toString(16);\n  if (hex.length % 2 === 1) hex = \"0\" + hex;\n\n  const bytes = new Uint8Array(new ArrayBuffer(8));\n  let i = 0;\n  for (const hexByte of hex.match(/.{2}/g)!.reverse()) {\n    bytes.set([parseInt(hexByte, 16)], i++);\n    value >>= EIGHT;\n  }\n  return Base64.fromByteArray(bytes);\n}\n\nexport function slowBase64ToBigInt(encoded: string): bigint {\n  const integerBytes = Base64.toByteArray(encoded);\n  if (integerBytes.byteLength !== 8) {\n    throw new Error(\n      `Received ${integerBytes.byteLength} bytes, expected 8 for $integer`\n    );\n  }\n  let value = ZERO;\n  let power = ZERO;\n  for (const byte of integerBytes) {\n    value += BigInt(byte) * TWOFIFTYSIX ** power;\n    power++;\n  }\n  if (value > MAX_INT64) {\n    value += MIN_INT64 + MIN_INT64;\n  }\n  return value;\n}\n\nexport function modernBigIntToBase64(value: bigint): string {\n  if (value < MIN_INT64 || MAX_INT64 < value) {\n    throw new Error(\n      `BigInt ${value} does not fit into a 64-bit signed integer.`\n    );\n  }\n  const buffer = new ArrayBuffer(8);\n  new DataView(buffer).setBigInt64(0, value, true);\n  return Base64.fromByteArray(new Uint8Array(buffer));\n}\n\nexport function modernBase64ToBigInt(encoded: string): bigint {\n  const integerBytes = Base64.toByteArray(encoded);\n  if (integerBytes.byteLength !== 8) {\n    throw new Error(\n      `Received ${integerBytes.byteLength} bytes, expected 8 for $integer`\n    );\n  }\n  const intBytesView = new DataView(integerBytes.buffer);\n  return intBytesView.getBigInt64(0, true);\n}\n\n// Fall back to a slower version on Safari 14 which lacks these APIs.\nexport const bigIntToBase64 = (DataView.prototype as any).setBigInt64\n  ? modernBigIntToBase64\n  : slowBigIntToBase64;\nexport const base64ToBigInt = (DataView.prototype as any).getBigInt64\n  ? modernBase64ToBigInt\n  : slowBase64ToBigInt;\n\nconst MAX_IDENTIFIER_LEN = 64;\nconst ALL_UNDERSCORES = /^_+$/;\nconst IDENTIFIER_REGEX = /^[a-zA-Z_][a-zA-Z0-9_]{0,63}$/;\n\nfunction validateObjectField(k: string) {\n  if (k.length === 0) {\n    throw new Error(\"Empty field names are disallowed.\");\n  }\n  if (k.length > MAX_IDENTIFIER_LEN) {\n    throw new Error(\n      `Field name ${k} exceeds maximum field name length ${MAX_IDENTIFIER_LEN}.`\n    );\n  }\n  if (k.startsWith(\"$\")) {\n    throw new Error(`Field name ${k} starts with a '$', which is reserved.`);\n  }\n  if (ALL_UNDERSCORES.test(k)) {\n    throw new Error(`Field name ${k} can't exclusively be underscores.`);\n  }\n  if (!IDENTIFIER_REGEX.test(k)) {\n    throw new Error(\n      `Field name ${k} must only contain alphanumeric characters or underscores and can't start with a number.`\n    );\n  }\n}\n\nfunction jsonToConvexInternal(value: JSONValue): Value {\n  if (value === null) {\n    return value;\n  }\n  if (typeof value === \"boolean\") {\n    return value;\n  }\n  if (typeof value === \"number\") {\n    return value;\n  }\n  if (typeof value === \"string\") {\n    return value;\n  }\n  if (value instanceof Array) {\n    return value.map(jsonToConvexInternal);\n  }\n  if (typeof value !== \"object\") {\n    throw new Error(`Unexpected type of ${value}`);\n  }\n  const entries = Object.entries(value);\n  if (entries.length === 1) {\n    const key = entries[0][0];\n    if (key === \"$id\" || key === \"$weakRef\" || key === \"$strongRef\") {\n      return Id.fromJSON(value);\n    }\n    if (key === \"$bytes\") {\n      if (typeof value.$bytes !== \"string\") {\n        throw new Error(`Malformed $bytes field on ${value}`);\n      }\n      return Base64.toByteArray(value.$bytes).buffer;\n    }\n    if (key === \"$integer\") {\n      if (typeof value.$integer !== \"string\") {\n        throw new Error(`Malformed $integer field on ${value}`);\n      }\n      return base64ToBigInt(value.$integer);\n    }\n    if (key === \"$float\") {\n      if (typeof value.$float !== \"string\") {\n        throw new Error(`Malformed $float field on ${value}`);\n      }\n      const floatBytes = Base64.toByteArray(value.$float);\n      if (floatBytes.byteLength !== 8) {\n        throw new Error(\n          `Received ${floatBytes.byteLength} bytes, expected 8 for $float`\n        );\n      }\n      const floatBytesView = new DataView(floatBytes.buffer);\n      const float = floatBytesView.getFloat64(0, LITTLE_ENDIAN);\n      if (!isSpecial(float)) {\n        throw new Error(`Float ${float} should be encoded as a number`);\n      }\n      return float;\n    }\n    if (key === \"$set\") {\n      if (!(value.$set instanceof Array)) {\n        throw new Error(`Malformed $set field on ${value}`);\n      }\n      return new Set(value.$set.map(jsonToConvexInternal));\n    }\n    if (key === \"$map\") {\n      if (!(value.$map instanceof Array)) {\n        throw new Error(`Malformed $map field on ${value}`);\n      }\n      const map = new Map();\n      for (const pair of value.$map) {\n        if (!(pair instanceof Array) || pair.length !== 2) {\n          throw new Error(`Malformed pair in $map ${value}`);\n        }\n        const k = jsonToConvexInternal(pair[0]);\n        const v = jsonToConvexInternal(pair[1]);\n        map.set(k, v);\n      }\n      return map;\n    }\n  }\n  const out: { [key: string]: Value } = {};\n  for (const [k, v] of Object.entries(value)) {\n    validateObjectField(k);\n    out[k] = jsonToConvexInternal(v);\n  }\n  return out;\n}\n\n/**\n * Parse a Convex value from its JSON representation.\n *\n * This function will revive classes like {@link GenericId} that have been serialized to JSON, parse out `BigInt`s, and so on.\n *\n * To learn more about Convex values, see [Types](https://docs.convex.dev/using/types).\n *\n * @param value - The JSON representation of a Convex value previously created with {@link convexToJson}.\n * @returns The JavaScript representation of the Convex value.\n *\n * @public\n */\nexport function jsonToConvex(value: JSONValue): Value {\n  return jsonToConvexInternal(value);\n}\n\nfunction stringifyValueForError(value: any) {\n  return JSON.stringify(value, (_key, value) => {\n    if (value === undefined) {\n      // By default `JSON.stringify` will serialize `undefined` to `null` which\n      // produces a confusing error message. Use `\"undefined\"` instead.\n      // Ideally we'd use a pretty-printing library that prints `undefined`\n      // (no quotes), but it might not be worth the bundle size cost.\n      return \"undefined\";\n    }\n    return value;\n  });\n}\n\nfunction convexToJsonInternal(\n  value: Value,\n  originalValue: Value,\n  context: string\n): JSONValue {\n  if (value === undefined) {\n    const contextText =\n      context &&\n      ` (present at path ${context} in original object ${stringifyValueForError(\n        originalValue\n      )})`;\n    throw new Error(\n      `undefined is not a valid Convex value${contextText}. To learn about Convex's supported types, see https://docs.convex.dev/using/types.`\n    );\n  }\n  if (value === null) {\n    return value;\n  }\n  if (value instanceof Id) {\n    return value.toJSON();\n  }\n  if (typeof value === \"bigint\") {\n    if (value < MIN_INT64 || MAX_INT64 < value) {\n      throw new Error(\n        `BigInt ${value} does not fit into a 64-bit signed integer.`\n      );\n    }\n    return { $integer: bigIntToBase64(value) };\n  }\n  if (typeof value === \"number\") {\n    if (isSpecial(value)) {\n      const buffer = new ArrayBuffer(8);\n      new DataView(buffer).setFloat64(0, value, LITTLE_ENDIAN);\n      return { $float: Base64.fromByteArray(new Uint8Array(buffer)) };\n    } else {\n      return value;\n    }\n  }\n  if (typeof value === \"boolean\") {\n    return value;\n  }\n  if (typeof value === \"string\") {\n    return value;\n  }\n  if (value instanceof ArrayBuffer) {\n    return { $bytes: Base64.fromByteArray(new Uint8Array(value)) };\n  }\n  if (value instanceof Array) {\n    return value.map((value, i) =>\n      convexToJsonInternal(value, originalValue, context + `[${i}]`)\n    );\n  }\n  if (value instanceof Set) {\n    return {\n      $set: [...value].map((value, i) =>\n        convexToJsonInternal(value, originalValue, context + `.keys()[${i}]`)\n      ),\n    };\n  }\n  if (value instanceof Map) {\n    return {\n      $map: [...value].map(([k, v], i) => {\n        const jsonKey = convexToJsonInternal(\n          k,\n          originalValue,\n          context + `.keys()[${i}]`\n        );\n        const jsonValue = convexToJsonInternal(\n          v,\n          originalValue,\n          context + `.values()[${i}]`\n        );\n        return [jsonKey, jsonValue];\n      }),\n    };\n  }\n\n  if (typeof value !== \"object\") {\n    throw new Error(\n      `${value} is not a supported Convex type (present at path ${context} in original object ${stringifyValueForError(\n        originalValue\n      )}). To learn about Convex's supported types, see https://docs.convex.dev/using/types.`\n    );\n  }\n\n  const prototype = Object.getPrototypeOf(value);\n  if (prototype !== null && prototype !== Object.prototype) {\n    throw new Error(\n      `${value} is not a supported Convex type (present at path ${context} in original object ${stringifyValueForError(\n        originalValue\n      )}). To learn about Convex's supported types, see https://docs.convex.dev/using/types.`\n    );\n  }\n\n  const out: { [key: string]: JSONValue } = {};\n  for (const [k, v] of Object.entries(value)) {\n    validateObjectField(k);\n    out[k] = convexToJsonInternal(v, originalValue, context + `.${k}`);\n  }\n  return out;\n}\n\n/**\n * Convert a Convex value to its JSON representation.\n *\n * Use {@link jsonToConvex} to recreate the original value.\n *\n * To learn more about Convex values, see [Types](https://docs.convex.dev/using/types).\n *\n * @param value - A Convex value to convert into JSON.\n * @returns The JSON representation of `value`.\n *\n * @public\n */\nexport function convexToJson(value: Value): JSONValue {\n  return convexToJsonInternal(value, value, \"\");\n}\n"],
  "mappings": "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",
  "names": ["toByteArray", "fromByteArray", "len", "i", "len2", "value"]
}
